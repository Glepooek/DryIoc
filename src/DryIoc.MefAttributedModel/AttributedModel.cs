// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2013-2024 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

namespace DryIoc.MefAttributedModel;

using System;
using System.Collections.Generic;
using System.ComponentModel.Composition;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Diagnostics;

using DryIocAttributes;
using DryIoc.ImTools;
using DryIoc.FastExpressionCompiler.LightExpression;

#nullable disable

/// <summary>Implements MEF Attributed Programming Model.
/// Documentation is available at https://github.com/dadhi/DryIoc/blob/master/docs/DryIoc.Docs/Extensions/MefAttributedModel.md </summary>
public static class AttributedModel
{
    /// <summary>Maps the supported reuse types to respective DryIoc reuse.</summary>
    public static readonly ImHashMap<ReuseType, Func<object, IReuse>> SupportedReuseTypes =
        ImHashMap<ReuseType, Func<object, IReuse>>.Empty
            .AddOrUpdate(ReuseType.Transient, static _ => Reuse.Transient)
            .AddOrUpdate(ReuseType.Singleton, static _ => Reuse.Singleton)
            .AddOrUpdate(ReuseType.Scoped, static n => n == null ? Reuse.Scoped : n is object[] names ? Reuse.ScopedTo(names) : Reuse.ScopedTo(n))
            .AddOrUpdate(ReuseType.ResolutionScope, static _ => Reuse.Scoped)
            .AddOrUpdate(ReuseType.ScopedOrSingleton, static _ => Reuse.ScopedOrSingleton);

    private static readonly PropertiesAndFieldsSelector _getImportedPropertiesAndFields =
        PropertiesAndFields.All(serviceInfo: GetImportedPropertiesAndFieldsOnly);

    private static readonly Made _defaultImportMadeOf = Made.Of(
        static request => GetImportingConstructor(request),
        GetImportedParameter,
        _getImportedPropertiesAndFields);

    /// <summary>Adjusts the rules to provide the full MEF compatibility.</summary>
    public static Rules WithMefRules(this Rules rules)
    {
        var prevFactorySelector = rules.FactoryMethodOrSelector;
        var importMadeOf = prevFactorySelector == null
            ? _defaultImportMadeOf
            : Made.Of(
                // don't make this lambda static because we need the previous factory selector, 
                // and not the current one from the `request.Rules`, otherwise it will be recursive call to the fall back method.
                request => GetImportingConstructor(request, prevFactorySelector),
                GetImportedParameter,
                _getImportedPropertiesAndFields);

        return rules.With(importMadeOf)
            .WithDefaultReuse(Reuse.Singleton)
            .WithTrackingDisposableTransients();
    }

    /// <summary>Adjusts the rules with <see cref="WithMefRules"/> to provide the full MEF compatibility.
    /// In addition registers the MEF specific wrappers, and adds support for <see cref="IPartImportsSatisfiedNotification"/>.</summary>
    public static IContainer WithMef(this IContainer container) =>
        container.With(static r => r.WithMefRules().WithMultipleSameServiceKeyForTheServiceType())
            .WithImportsSatisfiedNotification()
            .WithMefSpecificWrappers();

    // hello, Max!!! we are Martians.
    /// <summary>The basic rules to support MEF/DryIoc Attributes for
    /// specifying service construction via <see cref="ImportingConstructorAttribute"/>,
    /// and for specifying injected dependencies via Import attributes.</summary>
    public static Rules WithMefAttributedModel(this Rules rules) =>
        rules.WithMefRules();

    /// <summary>Applies the <see cref="WithMefAttributedModel(Rules)"/> to the container.</summary>
    public static IContainer WithMefAttributedModel(this IContainer container) =>
        container.With(WithMefAttributedModel);

    #region IPartImportsSatisfiedNotification support

    /// <summary>Registers <see cref="IPartImportsSatisfiedNotification"/> calling decorator into container.
    /// It is not directly related to MEF Exports and Imports, and may be used for notifying the injection
    /// is completed for normal DryIoc registrations.</summary>
    /// <param name="container">Container to support.</param>
    /// <returns>The container with made registration.</returns>
    public static IContainer WithImportsSatisfiedNotification(this IContainer container)
    {
        var made = Made.Of(typeof(AttributedModel).SingleMethod(nameof(NotifyImportsSatisfied), includeNonPublic: true));

        var decoratorSetup = Setup.DecoratorWith(
            r => r.GetKnownImplementationOrServiceType().IsAssignableTo<IPartImportsSatisfiedNotification>(), // todo: @perf can we filter it without registering the `object` decorator
            order: int.MinValue, // Important, sets the decorator as a first one, so it will always being called
            useDecorateeReuse: true);

        container.Register<object>(made: made, setup: decoratorSetup);

        return container;
    }

    internal static TService NotifyImportsSatisfied<TService>(TService service)
    {
        ((IPartImportsSatisfiedNotification)service).OnImportsSatisfied();
        return service;
    }

    #endregion

    #region ExportFactory<T>, ExportFactory<T, TMetadata> and Lazy<T, TMetadata> support

    /// <summary>Registers MEF-specific wrappers into the container.</summary>
    /// <remarks>MEF-specific wrappers are: <see cref="ExportFactory{T}"/>,
    /// <see cref="ExportFactory{T, TMetadata}"/> and <see cref="Lazy{T, TMetadata}"/>.</remarks>
    /// <param name="container">Container to support.</param>
    /// <returns>The container with registration.</returns>
    public static IContainer WithMefSpecificWrappers(this IContainer container)
    {
        // todo: @perf optimize to use unwrapped factory
        container.Register(typeof(ExportFactory<>),
            made: _createExportFactoryMethod,
            setup: Setup.Wrapper);

        // todo: @perf optimize to use unwrapped factory the same as GetLazyMetadataExpressionOrDefault
        container.Register(typeof(ExportFactory<,>),
            made: _createExportFactoryWithMetadataMethod,
            setup: Setup.WrapperWith(0));

        container.Register(typeof(Lazy<,>),
            WrapperExpressionFactory.Of(GetLazyMetadataExpressionOrDefault, Setup.WrapperWith(0)));

        return container;
    }

    internal static Expression GetLazyMetadataExpressionOrDefault(DryIoc.Request request, Factory serviceFactory = null)
    {
        var wrapperType = request.ActualServiceType;
        var typeArgs = wrapperType.GetGenericArguments();
        var serviceType = typeArgs[0];
        var metadataType = typeArgs[1];

        var details = request.GetServiceDetails();
        var serviceKey = details.ServiceKey;

        var container = request.Container;
        var requiredServiceType = container.GetWrappedType(serviceType, details.RequiredServiceType);

        // The factory is passed from the higher wrapper (collection or other).
        // It was already checked by the higher wrapper so no need to repeat the check here.
        if (serviceFactory != null)
        {
            // The check is only relevant to metadata, the higher wrappers know nothing about it.
            if (!serviceFactory.MatchMetadataType(metadataType))
                return null;
        }
        else // todo: @simplify factor this section both here and in the Container into the standalone method
        {
            var factories = container.GetAllServiceFactoriesPlusForOpenGeneric(requiredServiceType);
            if (factories.Length == 0)
                return null;

            if (serviceKey != null)
            {
                factories = factories.Match(serviceKey, static (key, f) => key.MatchToNotNullRegisteredKey(f.Key));
                if (factories.Length == 0)
                    return null;
            }

            // if the service keys for some reason are not unique
            factories = factories.Match(metadataType, static (mType, f) => f.Value.MatchMetadataType(mType));
            if (factories.Length == 0)
                return null;

            // Prevent non-determinism when more than 1 factory is matching the metadata
            if (factories.Length > 1)
            {
                if (details.IfUnresolved == DryIoc.IfUnresolved.Throw)
                    Throw.It(DryIoc.Error.UnableToSelectFromManyRegistrationsWithMatchingMetadata, metadataType, factories, request);
                return null;
            }

            var keyedFactory = factories[0];
            if (keyedFactory == null)
                return null;

            // The key may be different in case of initial serviceKey was null.
            // It even may be a non-default key, see Should_resolve_any_named_service_with_corresponding_metadata_If_name_is_not_specified_in_resolve
            serviceKey = keyedFactory.Key;
            serviceFactory = keyedFactory.Value;
        }

        var serviceRequest = request.Push(ServiceInfo.Of(serviceType, serviceKey),
            RequestFlags.IsWrappedInFunc | RequestFlags.IsDirectlyWrappedInFunc | RequestFlags.IsResolutionCall);

        var factory = requiredServiceType == serviceType
            // We at least looking at the unwrapped type, so we may check that type factory condition
            ? serviceRequest.MatchGeneratedFactoryByReuseAndConditionOrNull(serviceFactory)
            // Going to resolve the nested wrapper (the usual case when required is different from the service type)
            : container.ResolveFactory(serviceRequest);

        if (factory == null)
            return null;

        // we are not setting the unwrapped service factory here because it does not matter for resolution call
        serviceRequest = serviceRequest.WithResolvedFactory(factory, skipRecursiveDependencyCheck: true);
        var serviceExpr = Resolver.CreateResolutionExpression(serviceRequest, openResolutionScope: false, stopRecursiveDependencyCheck: true);

        var funcType = typeof(Func<>).MakeGenericType(serviceType);
        var wrapperCtor = wrapperType.Constructor(funcType, metadataType);

        var resultMetadata = serviceFactory.Setup.GetMetadataValueMatchedByMetadataType(metadataType);
        var metadataExpr = container.GetConstantExpression(resultMetadata, metadataType);

        return Expression.New(wrapperCtor,
            Expression.Lambda(funcType, serviceExpr, ArrayTools.Empty<ParameterExpression>(), serviceType),
            metadataExpr);
    }

    // todo: @perf create the variant with IDisposable part, so we don't need the Action
    /// <summary>Proxy for the tuple parameter to <see cref="ExportFactory{T}"/>.
    /// Required to cover for missing Tuple in .NET 4.0 and lower.
    /// Provides implicit conversion in both <see cref="KeyValuePair{TKey,TValue}"/> and <see cref="Tuple{T1,T2}"/>.</summary>
    public sealed class PartAndDisposeActionPair<TPart>
    {
        /// <summary>Conversion operator.</summary> <param name="source">to be converted</param>
        public static implicit operator KeyValuePair<TPart, Action>(PartAndDisposeActionPair<TPart> source) =>
            source.Part.Pair(source.DisposeAction);

        /// <summary>Conversion operator.</summary> <param name="source">to be converted</param>
        public static implicit operator Tuple<TPart, Action>(PartAndDisposeActionPair<TPart> source) =>
            Tuple.Create(source.Part, source.DisposeAction);

        /// <summary>Created export part.</summary>
        public readonly TPart Part;

        /// <summary>Action to dispose the created part and its dependencies</summary>
        public readonly Action DisposeAction;

        /// <summary>Creates a proxy by wrapping the Part and Dispose action.</summary>
        public PartAndDisposeActionPair(TPart part, Action disposeAction)
        {
            Part = part;
            DisposeAction = disposeAction;
        }
    }

    /// <summary>Creates the <see cref="ExportFactory{T}"/>.</summary>
    internal static ExportFactory<T> CreateExportFactory<T>(IContainer container, DryIoc.IfUnresolved ifUnresolved)
    {
        // check if the service is resolvable
        var func = container.Resolve<Func<T>>(ifUnresolved: ifUnresolved);
        if (func == null)
            return null;

        if (container.Rules.DefaultReuse != Reuse.Scoped)
            container = container.With(static r => r.WithDefaultReuse(Reuse.Scoped));

        return new ExportFactory<T>(() =>
        {
            var scope = container.OpenScope();
            try
            {
                return new PartAndDisposeActionPair<T>(scope.Resolve<T>(), () => scope.Dispose());
            }
            catch
            {
                scope.Dispose();
                throw;
            }
        });
    }

    private static readonly Made _createExportFactoryMethod = Made.Of(
        typeof(AttributedModel).SingleMethod(nameof(CreateExportFactory), includeNonPublic: true),
        parameters: Parameters.Of.Type(request => request.IfUnresolved));

    /// <summary>Creates the <see cref="ExportFactory{T, TMetadata}"/>.</summary>
    internal static ExportFactory<T, TMetadata> CreateExportFactoryWithMetadata<T, TMetadata>(
        Meta<KeyValuePair<object, Func<T>>, TMetadata> metaFactory, IContainer container) =>
        new ExportFactory<T, TMetadata>(() =>
        {
            var scope = container.With(static r => r.WithDefaultReuse(Reuse.Scoped)).OpenScope();
            try
            {
                var result = scope.Resolve<T>(serviceKey: metaFactory.Value.Key);
                return new PartAndDisposeActionPair<T>(result, scope.Dispose);
            }
            catch
            {
                scope.Dispose();
                throw;
            }
        },
        metaFactory.Metadata);

    private static readonly Made _createExportFactoryWithMetadataMethod = Made.Of(
        typeof(AttributedModel).SingleMethod(nameof(CreateExportFactoryWithMetadata), includeNonPublic: true));

    /// <summary>Creates the <see cref="Lazy{T, TMetadata}"/>.</summary>
    internal static Lazy<T, TMetadata> CreateLazyWithMetadata<T, TMetadata>(Meta<Lazy<T>, TMetadata> metaFactory) =>
        metaFactory == null || metaFactory.Value == null ? null :
        new Lazy<T, TMetadata>(() => metaFactory.Value.Value, metaFactory.Metadata);

    private static readonly Made _createLazyWithMetadataMethod = Made.Of(
        typeof(AttributedModel).SingleMethod(nameof(CreateLazyWithMetadata), includeNonPublic: true));

    #endregion

    /// <summary>Registers implementation type(s) with provided registrator/container.
    /// Expects the implementation type with the <see cref="ExportAttribute"/>, <see cref="ExportExAttribute"/> or <see cref="ExportManyAttribute"/>.</summary>
    public static void RegisterExports(this IRegistrator registrator, IEnumerable<Type> types) =>
        registrator.RegisterExports(types.ThrowIfNull().SelectMany(GetExportedRegistrations));

    /// <summary>Registers implementation type(s) with provided registrator/container.
    /// Expects the implementation type with or without the <see cref="ExportAttribute"/>, <see cref="ExportExAttribute"/> or <see cref="ExportManyAttribute"/>.</summary>
    public static void RegisterExportsAndTypes(this IRegistrator registrator, IEnumerable<Type> types) =>
        registrator.RegisterExports(types.ThrowIfNull().SelectMany(static t => GetExportedRegistrations(t, true)));

    /// <summary>Registers implementation type(s) with provided registrator/container.
    /// Expects the implementation type with the <see cref="ExportAttribute"/>, <see cref="ExportExAttribute"/> or <see cref="ExportManyAttribute"/>.</summary>
    public static void RegisterExports(this IRegistrator registrator, params Type[] types) =>
        registrator.RegisterExports((IEnumerable<Type>)types);

    /// <summary>Register the exports for a single Type and its Exported members if any.
    /// Returns the number of registrations - may be zero.</summary>
    public static int RegisterExports(this IRegistrator registrator, Type type)
    {
        var registrationInfos = type.GetExportedRegistrations();
        var registrationCount = 0;
        foreach (var info in registrationInfos)
            registrationCount += RegisterInfo(registrator, info);
        return registrationCount;
    }

    /// <summary>Register the exports for a single Type and its Exported members if any.
    /// Customize the exports. You may skip the registration by returning null from <paramref name="checkAndCustomize"/>.
    /// Returns the number of registrations - may be zero.</summary>
    public static int RegisterExports(this IRegistrator registrator, Type type,
        Func<ExportedRegistrationInfo, ExportedRegistrationInfo> checkAndCustomize)
    {
        Debug.Assert(checkAndCustomize != null, "checkAndCustomize != null");
        var registrationInfos = type.GetExportedRegistrations();
        var registrationCount = 0;
        foreach (var info in registrationInfos)
        {
            var customInfo = checkAndCustomize(info);
            if (customInfo == null) continue;
            registrationCount += RegisterInfo(registrator, customInfo);
        }
        return registrationCount;
    }

    /// <summary>Registers implementation type(s) with provided registrator/container.
    /// Expects the implementation type with or without the <see cref="ExportAttribute"/>, <see cref="ExportExAttribute"/> or <see cref="ExportManyAttribute"/>.</summary>
    public static void RegisterExportsAndTypes(this IRegistrator registrator, params Type[] types) =>
        registrator.RegisterExportsAndTypes((IEnumerable<Type>)types);

    /// <summary>First scans (<see cref="Scan"/>) the provided assemblies to find the types annotated with
    /// <see cref="ExportAttribute"/>, <see cref="ExportExAttribute"/>, or <see cref="ExportManyAttribute"/>.
    /// Then registers the found types into registrator/container.</summary>
    public static void RegisterExports(this IRegistrator registrator, IEnumerable<Assembly> assemblies) =>
        registrator.RegisterExports(Scan(assemblies));

    /// <summary>First scans (<see cref="Scan"/>) the provided assemblies to find the types annotated with
    /// <see cref="ExportAttribute"/>, <see cref="ExportExAttribute"/>, or <see cref="ExportManyAttribute"/>.
    /// Then registers the found types into registrator/container.</summary>
    public static void RegisterExports(this IRegistrator registrator, params Assembly[] assemblies) =>
        registrator.RegisterExports((IEnumerable<Assembly>)assemblies);

    /// <summary>Registers new factories into registrator/container based on provided registration info's, which
    /// is serializable DTO for registration.</summary>
    public static void RegisterExports(this IRegistrator registrator, IEnumerable<ExportedRegistrationInfo> registrations)
    {
        foreach (var info in registrations)
            RegisterInfo(registrator, info);
    }

    /// <summary>Helper to apply laziness to provided registrations.</summary>
    public static IEnumerable<ExportedRegistrationInfo> MakeLazyAndEnsureUniqueServiceKeys(
        this IEnumerable<ExportedRegistrationInfo> registrations)
    {
        var keyIndex = new ServiceKeyToTypeIndex();
        return registrations.Select(info => info.MakeLazy().EnsureUniqueExportServiceKeys(keyIndex));
    }

    /// <summary>Registers factories into registrator/container based on single provided info, which could
    /// contain multiple exported services with single implementation.
    /// Returns the number of actual registrations.</summary>
    public static int RegisterInfo(this IRegistrator registrator, ExportedRegistrationInfo info)
    {
        var exports = info.Exports;
        if (exports == null || exports.Length == 0)
            return 0; // nothing to register

        // factory is used for all exports of implementation
        var factory = info.CreateFactory();
        for (var i = 0; i < exports.Length; i++)
        {
            var export = exports[i];
            registrator.Register(factory, export.ServiceType, export.ServiceKey, export.IfAlreadyRegistered,
                isStaticallyChecked: true); // set to true, because we're reflecting from the compiler checked code
        }
        return exports.Length;
    }

    /// <summary>Scans assemblies to find concrete type annotated with <see cref="ExportAttribute"/>, or <see cref="ExportManyAttribute"/>
    /// attributes, and create serializable DTO with all information required for registering of exported types.</summary>
    public static IEnumerable<ExportedRegistrationInfo> Scan(IEnumerable<Assembly> assemblies) =>
        assemblies.Distinct().SelectMany(Portable.GetAssemblyTypes).SelectMany(GetExportedRegistrations);

    /// <summary>Creates registration info DTOs for provided type and/or for exported members.
    /// If no exports found, the method returns empty enumerable.</summary>
    public static IEnumerable<ExportedRegistrationInfo> GetExportedRegistrations(this Type type) => GetExportedRegistrations(type, false);

    // todo: Review the need for factory service key
    // - May be export factory AsWrapper to hide from collection resolution
    // - Use an unique (GUID) service key
    private static readonly Attribute[] _factoryTypeAttributes = new Attribute[] { new ExportAttribute(Constants.InstanceFactory) };

    /// <summary>Creates registration info DTOs for provided type and/or for exported members.
    /// If no exports found, the method returns empty enumerable.</summary>
    public static IEnumerable<ExportedRegistrationInfo> GetExportedRegistrations(this Type type, bool shouldRegisterWithoutExport)
    {
        if (!CanBeExported(type))
            yield break;

        ExportedRegistrationInfo typeRegistrationInfo = null;

        // Export does not make sense for static or abstract type
        // because the instance of such type can't be created (resolved).
        if (!type.IsStatic() && !type.IsAbstract)
        {
            var typeAttributes = GetAllExportAttributes(type);
            if (IsExportDefined(typeAttributes, shouldRegisterWithoutExport))
            {
                typeRegistrationInfo = GetRegistrationInfoOrDefault(type, typeAttributes, shouldRegisterWithoutExport);
                if (typeRegistrationInfo != null)
                    yield return typeRegistrationInfo;
            }
        }

        var members = type.GetAllMembers(includeBase: true);
        foreach (var member in members)
        {
            var memberAttributes = member.GetAttributes().ToArrayOrSelf();
            if (!IsExportDefined(memberAttributes, false))
                continue;

            var memberReturnType = member.GetReturnTypeOrDefault();
            var memberRegistrationInfo = GetRegistrationInfoOrDefault(memberReturnType, memberAttributes).ThrowIfNull();

            var factoryMethod = new FactoryMethodInfo
            {
                DeclaringType = type,
                MemberName = member.Name
            };

            if (!member.IsStatic())
            {
                // if no export for instance factory, then add one
                if (typeRegistrationInfo == null)
                {
                    typeRegistrationInfo = GetRegistrationInfoOrDefault(type, _factoryTypeAttributes).ThrowIfNull();
                    yield return typeRegistrationInfo;
                }

                // note: the first export is used for instance factory, the rest is ignored
                factoryMethod.InstanceFactory = typeRegistrationInfo.Exports[0];
            }

            if (member is MethodInfo method)
            {
                factoryMethod.MethodParameterTypeFullNamesOrNames =
                    method.GetParameters().Map(static p => p.ParameterType.FullName ?? p.ParameterType.Name);

                // the only possibility (for now) for registering completely generic T service
                // is registering it as an Object
                if (memberReturnType.IsGenericParameter &&
                    memberRegistrationInfo.FactoryType == DryIoc.FactoryType.Decorator)
                {
                    var exports = memberRegistrationInfo.Exports;
                    for (var i = 0; i < exports.Length; ++i)
                        exports[i].ServiceType = typeof(object);
                }
            }

            memberRegistrationInfo.FactoryMethodInfo = factoryMethod;

            // If member reuse is not provided get it from the declaring type (fix for #355)
            if (memberRegistrationInfo.Reuse == null)
            {
                if (typeRegistrationInfo != null)
                    memberRegistrationInfo.Reuse = typeRegistrationInfo.Reuse;
                else
                {
                    var creationPolicyAttrs = type.GetAttributes(typeof(PartCreationPolicyAttribute), inherit: true);
                    if (creationPolicyAttrs.Length != 0)
                        memberRegistrationInfo.Reuse = GetReuseInfo((PartCreationPolicyAttribute)creationPolicyAttrs[0]);
                }
            }

            yield return memberRegistrationInfo;
        }
    }

    /// <summary>Creates and index by service type name.
    /// Then returns the factory provider which uses index for fast registration discovery.</summary>
    /// <param name="lazyRegistrations">Registrations with <see cref="ExportedRegistrationInfo.IsLazy"/> set to true.
    /// Consider to call <see cref="MakeLazyAndEnsureUniqueServiceKeys"/> on registrations before passing them here.</param>
    /// <param name="getAssembly">Assembly to load type by name from. NOTE: The assembly will be loaded only once!</param>
    /// <param name="ifAlreadyRegistered">(optional) Keep existing registrations by default.</param>
    /// <param name="otherServiceExports">(optional) Index to share with other providers,
    /// if not specified - each provider will use its own. The index maps the full service name
    /// from <paramref name="lazyRegistrations"/> to its registration and (optional) service key pairs.</param>
    /// <returns><see cref="Rules.DynamicRegistrationProvider"/></returns>
    public static Rules.DynamicRegistrationProvider GetLazyTypeRegistrationProvider(
        this IEnumerable<ExportedRegistrationInfo> lazyRegistrations, Func<Assembly> getAssembly,
        IfAlreadyRegistered ifAlreadyRegistered = IfAlreadyRegistered.Keep,
        IDictionary<string, IList<KeyValuePair<object, ExportedRegistrationInfo>>> otherServiceExports = null)
    {
        var assembly = new Lazy<Assembly>(getAssembly);
        return lazyRegistrations.GetLazyTypeRegistrationProvider(
            t => assembly.Value.GetType(t), ifAlreadyRegistered, otherServiceExports);
    }

    /// <summary>Creates and index by service type name.
    /// Then returns the factory provider which uses index for fast registration discovery.</summary>
    /// <param name="lazyRegistrations">Registrations with <see cref="ExportedRegistrationInfo.IsLazy"/> set to true.
    /// Consider to call <see cref="MakeLazyAndEnsureUniqueServiceKeys"/> on registrations before passing them here.</param>
    /// <param name="typeProvider">Required for Lazy registration info to create actual Type from type name.</param>
    /// <param name="ifAlreadyRegistered">(optional) Keep existing registrations by default.</param>
    /// <param name="otherServiceExports">(optional) Index to share with other providers,
    /// if not specified - each provider will use its own. The index maps the full service name
    /// from <paramref name="lazyRegistrations"/> to its registration and (optional) service key pairs.</param>
    /// <returns><see cref="Rules.DynamicRegistrationProvider"/></returns>
    public static Rules.DynamicRegistrationProvider GetLazyTypeRegistrationProvider(
        this IEnumerable<ExportedRegistrationInfo> lazyRegistrations,
        Func<string, Type> typeProvider,
        IfAlreadyRegistered ifAlreadyRegistered = IfAlreadyRegistered.Keep,
        IDictionary<string, IList<KeyValuePair<object, ExportedRegistrationInfo>>> otherServiceExports = null)
    {
        otherServiceExports ??= new Dictionary<string, IList<KeyValuePair<object, ExportedRegistrationInfo>>>();

        // Creating index or adding new registrations to the index.
        foreach (var reg in lazyRegistrations)
        {
            var exports = reg.Exports;
            for (var i = 0; i < exports.Length; i++)
            {
                var e = exports[i];

                IList<KeyValuePair<object, ExportedRegistrationInfo>> expRegs;
                if (!otherServiceExports.TryGetValue(e.ServiceTypeFullName, out expRegs))
                    otherServiceExports[e.ServiceTypeFullName] =
                        expRegs = new List<KeyValuePair<object, ExportedRegistrationInfo>>();

                expRegs.Add(e.ServiceKey.Pair(reg));
            }
        }

        return (serviceType, _) =>
        {
            IList<KeyValuePair<object, ExportedRegistrationInfo>> regs;
            return otherServiceExports.TryGetValue(serviceType.FullName.ThrowIfNull(), out regs)
                ? regs.Map(r => new DynamicRegistration(r.Value.GetOrCreateFactory(typeProvider), ifAlreadyRegistered, r.Key))
                : null;
        };
    }

    private static bool CanBeExported(Type type) => type.IsClass && !type.IsCompilerGenerated();

    private static ReuseInfo GetReuseInfo(PartCreationPolicyAttribute attribute) =>
        new ReuseInfo { ReuseType = attribute.CreationPolicy == CreationPolicy.NonShared ? ReuseType.Transient : ReuseType.Singleton };

    /// <summary>Converts reuse info into pre-defined (<see cref="SupportedReuseTypes"/>) or custom reuse object.</summary>
    public static IReuse GetReuse(ReuseInfo reuseInfo)
    {
        if (reuseInfo == null)
            return null; // unspecified reuse, decided by container rules

        if (reuseInfo.CustomReuseType != null)
            return
                reuseInfo.ScopeName == null && (reuseInfo.ScopeNames == null || reuseInfo.ScopeNames.Length == 0) ?
                    (IReuse)Activator.CreateInstance(reuseInfo.CustomReuseType) :
                reuseInfo.ScopeName != null ?
                    (IReuse)Activator.CreateInstance(reuseInfo.CustomReuseType, reuseInfo.ScopeName) :
                    (IReuse)Activator.CreateInstance(reuseInfo.CustomReuseType, reuseInfo.ScopeNames);

        return SupportedReuseTypes.GetValueOrDefault(reuseInfo.ReuseType)
            .ThrowIfNull(Error.UnsupportedReuseType, reuseInfo.ReuseType)
            .Invoke(reuseInfo.ScopeName ?? (object)reuseInfo.ScopeNames);
    }

    #region Rules

    private static FactoryMethod GetImportingConstructor(DryIoc.Request request, object fallbackMethodOrSelector = null)
    {
        var implType = request.ImplementationType;

        var allCtors = implType.PublicAndNonPublicInstanceConstructors().ToArrayOrSelf();

        // 1. Find any single importing constructor
        var selectedCtor = allCtors.FindFirstSingle(out var nextCtorIndex,
            static c => c.GetAttributes(typeof(ImportingConstructorAttribute)).Any());
        if (selectedCtor != null)
            return FactoryMethod.Of(selectedCtor);

        // 2. The rare case if we still have more importing constructors found, 
        // it is rare because multiple importing constructors probably a mistake
        if (nextCtorIndex != -1)
        {
            // 2.1. Find any public single importing constructor
            selectedCtor = allCtors.FindFirstSingle(out _,
                static c => c.IsPublic && c.GetAttributes(typeof(ImportingConstructorAttribute)).Any());
            if (selectedCtor != null)
                return FactoryMethod.Of(selectedCtor);
        }

        // 3. Try to fallback to constructor or method selector, it may be defined as ConstructorWithResolvableArguments
        if (fallbackMethodOrSelector != null)
        {
            var fallbackMethod = fallbackMethodOrSelector as FactoryMethod ?? ((FactoryMethodSelector)fallbackMethodOrSelector)(request);
            if (fallbackMethod != null)
                return fallbackMethod;
        }

        // 4. Find a single public constructor
        selectedCtor = allCtors.FindFirstSingle(out _, static c => c.IsPublic);
        if (selectedCtor != null)
            return FactoryMethod.Of(selectedCtor);

        // 5. Find a single default constructor
        selectedCtor = allCtors.FindFirstSingle(out _, static c => c.GetParameters().Length == 0);

        // Search is failed - give up
        selectedCtor.ThrowIfNull(Error.NoSingleCtorWithImportingAttr, implType, request);
        return FactoryMethod.Of(selectedCtor);
    }

    private static Func<ParameterInfo, ParameterServiceInfo> GetImportedParameter(DryIoc.Request request) => parameter =>
    {
        var serviceInfo = ParameterServiceInfo.Of(parameter);
        var attrs = parameter.GetAttributes().ToArrayOrSelf();
        return attrs.Length == 0 ? serviceInfo :
            serviceInfo.WithDetails(GetFirstImportDetailsOrNull(parameter.ParameterType, attrs, request));
    };

    private static PropertyOrFieldServiceInfo GetImportedPropertiesAndFieldsOnly(MemberInfo member, DryIoc.Request request)
    {
        var attributes = member.GetAttributes().ToArrayOrSelf();
        if (attributes.Length == 0)
            return null;

        var details = GetFirstImportDetailsOrNull(member.GetReturnTypeOrDefault(), attributes, request);
        if (details == null)
            return null;

        return PropertyOrFieldServiceInfo.Of(member).WithDetails(details);
    }

    private static ServiceDetails GetFirstImportDetailsOrNull(Type type, Attribute[] attributes, DryIoc.Request request) =>
        GetImportDetails(type, attributes, request) ?? GetImportExternalDetails(type, attributes, request);

    private static ServiceDetails GetImportDetails(Type type, Attribute[] attributes, DryIoc.Request request)
    {
        object serviceKey;
        Type requiredServiceType;
        var ifUnresolved = DryIoc.IfUnresolved.Throw;

        var metadata = GetRequiredMetadata(attributes);

        var import = GetSingleAttributeOrDefault<ImportAttribute>(attributes);
        if (import == null)
        {
            var importMany = GetSingleAttributeOrDefault<ImportManyAttribute>(attributes);
            if (importMany == null)
                return null;

            serviceKey = importMany.ContractName;
            requiredServiceType = importMany.ContractType;
        }
        else
        {
            serviceKey = import.ContractName;
            if (serviceKey == null && import is ImportExAttribute importEx)
                serviceKey = importEx.ContractKey;

            requiredServiceType = import.ContractType;
            if (import.AllowDefault)
                ifUnresolved = DryIoc.IfUnresolved.ReturnDefault;
        }

        // handle not-found, probably base or object type imports
        if (requiredServiceType == null & serviceKey != null)
            requiredServiceType = FindRequiredServiceTypeByServiceKey(type, request, serviceKey);

        return ServiceDetails.Of(requiredServiceType, serviceKey, ifUnresolved, null, metadata.Key, metadata.Value);
    }

    private static Type FindRequiredServiceTypeByServiceKey(Type type, DryIoc.Request request, object serviceKey)
    {
        var container = request.Container;
        var rules = container.Rules;
        if (!rules.HasMultipleSameServiceKeyForTheServiceType)
            return null;

        // may be null if service key is registered at all Or registered not through MEF
        var serviceTypes = rules.GetServiceTypesByServiceKeyOrDefault(serviceKey);
        if (serviceTypes == null)
            return null;

        // required when importing the wrappers
        var unwrappedType = container.GetWrappedType(type, null);

        // todo: @improve @feature today, we are not considering the Names of types (produced by MakeLazy).
        // first filter out non compatible / assignable types
        if (serviceTypes is Type singleType)
        {
            return unwrappedType.IsAssignableFrom(singleType) ? singleType : null;
        }
        else if (serviceTypes is KV<object, int> singleTypeWithCount)
        {
            return singleTypeWithCount.Key is Type t && unwrappedType.IsAssignableFrom(t) ? t : null;
        }
        else if (serviceTypes is object[] manyTypes)
        {
            Debug.Assert(manyTypes.Length > 1, "we use array only for 2 and more types/pairs with count");

            manyTypes = manyTypes.Match(unwrappedType, static (ut, x) =>
                x is Type t && ut.IsAssignableFrom(t) ||
                x is KV<object, int> kv && kv.Key is Type kt && ut.IsAssignableFrom(kt));

            if (manyTypes.Length > 1)
                Throw.It(Error.UnableToSelectFromMultipleTypes, manyTypes, KV.Of(serviceKey, type));

            return (manyTypes[0] as Type) ?? (((KV<object, int>)manyTypes[0]).Key as Type);
        }

        return null;
    }

    private static KeyValuePair<string, object> GetRequiredMetadata(Attribute[] attributes)
    {
        var withMetadataAttr = GetSingleAttributeOrDefault<WithMetadataAttribute>(attributes);
        var metadata = withMetadataAttr?.Metadata;
        var metadataKey = withMetadataAttr == null ? null
            : withMetadataAttr.MetadataKey ?? Constants.ExportMetadataDefaultKey;
        return metadataKey.Pair(metadata);
    }

    private static ServiceDetails GetImportExternalDetails(Type serviceType, Attribute[] attributes, DryIoc.Request request)
    {
        var import = GetSingleAttributeOrDefault<ImportExternalAttribute>(attributes);
        if (import == null)
            return null;

        var container = request.Container;
        serviceType = import.ContractType ?? container.GetWrappedType(serviceType, request.RequiredServiceType);
        var serviceKey = import.ContractKey;

        IDictionary<string, object> setupMetadata = null;

        // will be used for resolution and for registration setup, if service is not registered
        var metadataValue = import.Metadata;
        var metadataKey = import.MetadataKey;
        if (metadataKey == null && metadataValue != null) // set default key if absent
            metadataKey = Constants.ExportMetadataDefaultKey;

        if (metadataKey != null || metadataValue != null)
            setupMetadata = new Dictionary<string, object> { { metadataKey, metadataValue } };

        if (serviceKey != null)
        {
            var serviceKeyMetadata = (serviceKey.GetHashCode() + ":" + serviceType.FullName).Pair(serviceKey);

            setupMetadata = setupMetadata ?? new Dictionary<string, object>();
            setupMetadata.Add(serviceKeyMetadata.Key, serviceKeyMetadata.Value);

            if (metadataValue == null && metadataKey == null)
            {
                metadataKey = serviceKeyMetadata.Key;
                metadataValue = serviceKeyMetadata.Value;
            }
        }

        if (!container.IsRegistered(serviceType, serviceKey))
        {
            var implementationType = import.ImplementationType ?? serviceType;

            var reuseAttr = GetSingleAttributeOrDefault<ReuseAttribute>(attributes);
            var reuse = reuseAttr == null ? null
                : GetReuse(new ReuseInfo { ReuseType = reuseAttr.ReuseType, ScopeName = reuseAttr.ScopeName, ScopeNames = reuseAttr.ScopeNames });

            var impl = import.ConstructorSignature == null ? null
                : Made.Of(t => t.GetConstructorOrNull(args: import.ConstructorSignature));

            container.Register(serviceType, implementationType, reuse, impl,
                Setup.With(setupMetadata), IfAlreadyRegistered.Keep, serviceKey);
        }

        // the default because we intentionally register the service and expect it to be available
        var ifUnresolved = DryIoc.IfUnresolved.Throw;

        return ServiceDetails.Of(serviceType, serviceKey, ifUnresolved, null, metadataKey, metadataValue);
    }

    private static TAttribute GetSingleAttributeOrDefault<TAttribute>(Attribute[] attributes) where TAttribute : Attribute
    {
        TAttribute attr = null;
        for (var i = 0; i < attributes.Length & attr == null; i++)
            attr = attributes[i] as TAttribute;
        return attr;
    }

    #endregion

    #region Implementation

    private static ExportedRegistrationInfo GetRegistrationInfoOrDefault(Type type, Attribute[] attributes,
        bool shouldRegisterWithoutExport = false)
    {
        if (type.IsOpenGeneric())
            type = type.GetGenericTypeDefinition();

        var info = new ExportedRegistrationInfo { ImplementationType = type, Reuse = null };

        for (var attrIndex = 0; attrIndex < attributes.Length; attrIndex++)
        {
            var attribute = attributes[attrIndex];
            if (attribute is ExportExAttribute)
            {
                info.Exports = GetExportsFromExportExAttribute((ExportExAttribute)attribute, info, type);
            }
            else if (attribute is ExportManyAttribute)
            {
                info.Exports = GetExportsFromExportManyAttribute((ExportManyAttribute)attribute, info, type);
            }
            else if (attribute is ExportAttribute)
            {
                info.Exports = GetExportsFromExportAttribute((ExportAttribute)attribute, info, type);
            }
            else if (attribute is PartCreationPolicyAttribute)
            {
                info.Reuse = GetReuseInfo((PartCreationPolicyAttribute)attribute);
            }
            else if (attribute is ReuseAttribute)
            {
                var reuseAttr = (ReuseAttribute)attribute;
                info.Reuse = reuseAttr.CustomReuseType == null
                    ? new ReuseInfo { ReuseType = reuseAttr.ReuseType, ScopeName = reuseAttr.ScopeName, ScopeNames = reuseAttr.ScopeNames }
                    : new ReuseInfo { CustomReuseType = reuseAttr.CustomReuseType, ScopeName = reuseAttr.ScopeName, ScopeNames = reuseAttr.ScopeNames };
            }
            else if (attribute is OpenResolutionScopeAttribute)
            {
                info.OpenResolutionScope = true;
            }
            else if (attribute is DisposalOrderAttribute d)
            {
                info.DisposalOrder = d.RelativeValue;
            }
            else if (attribute is AvoidResolutionScopeTrackingAttribute)
            {
                info.AvoidResolutionScopeTracking = true;
            }
            else if (attribute is AsResolutionCallAttribute)
            {
                info.AsResolutionCall = true;
            }
            else if (attribute is AsResolutionRootAttribute)
            {
                info.AsResolutionRoot = true;
            }
            else if (attribute is WeaklyReferencedAttribute)
            {
                info.WeaklyReferenced = true;
            }
            else if (attribute is PreventDisposalAttribute)
            {
                info.PreventDisposal = true;
            }
            else if (attribute is AllowDisposableTransientAttribute)
            {
                info.AllowDisposableTransient = true;
            }
            else if (attribute is TrackDisposableTransientAttribute)
            {
                info.TrackDisposableTransient = true;
            }
            else if (attribute is UseParentReuseAttribute)
            {
                info.UseParentReuse = true;
            }
            else if (attribute is PreferInSingleServiceResolveAttribute)
            {
                info.PreferInSingleServiceResolve = true;
            }
            else if (attribute is AsWrapperAttribute)
            {
                PopulateWrapperInfoFromAttribute(info, (AsWrapperAttribute)attribute, type);
            }
            else if (attribute is AsDecoratorAttribute)
            {
                PopulateDecoratorInfoFromAttribute(info, (AsDecoratorAttribute)attribute, type);
            }
            else if (attribute is ExportConditionAttribute)
            {
                info.ConditionType = attribute.GetType();
            }

            if (attribute is ExportAttribute || attribute is WithMetadataAttribute ||
                attribute.GetType().GetAttributes(typeof(MetadataAttributeAttribute), true).Any())
            {
                info.HasMetadataAttribute = true;
            }
        }

        if (info.HasMetadataAttribute)
            info.InitExportedMetadata(attributes);

        if (info.Exports == null)
        {
            if (shouldRegisterWithoutExport)
                info.Exports = GetExportFromImplementationType(info, type);
            else
                Throw.It(Error.NoExport, type);
        }

        return info;
    }

    private static bool IsExportDefined(Attribute[] attributes, bool shouldRegisterWithoutExport)
    {
        if (shouldRegisterWithoutExport)
        {
            if (attributes.Length == 0)
                return true;

            for (var i = 0; i < attributes.Length; ++i)
            {
                var a = attributes[i];
                if (a is PartNotDiscoverableAttribute)
                    return false; // return earlier if part is not discoverable
            }
            return true;
        }

        if (attributes.Length == 0)
            return false;

        var exported = false;
        for (var i = 0; i < attributes.Length; ++i)
        {
            var a = attributes[i];
            if (a is PartNotDiscoverableAttribute)
                return false; // return earlier if part is not discoverable
            if (a is ExportAttribute || a is ExportManyAttribute)
                exported = true;
        }
        return exported;
    }

    private static ExportInfo[] GetExportsFromExportAttribute(ExportAttribute attribute,
        ExportedRegistrationInfo info, Type implementationType)
    {
        var export = new ExportInfo(attribute.ContractType ?? implementationType,
            attribute.ContractName ??
#pragma warning disable 618 // ExportWithKeyAttribute is Obsolete.
            (attribute is ExportWithKeyAttribute ? ((ExportWithKeyAttribute)attribute).ContractKey : null));
#pragma warning restore 618

        // Overrides the existing export with new one (will override export from Export Many)
        return info.Exports.AppendOrUpdate(export, info.Exports.IndexOf(export));
    }

    private static ExportInfo[] GetExportsFromExportExAttribute(ExportExAttribute attribute,
        ExportedRegistrationInfo info, Type implementationType)
    {
        var export = new ExportInfo(
            attribute.ContractType ?? implementationType,
            attribute.ContractKey,
            GetIfAlreadyRegistered(attribute.IfAlreadyExported));

        // Overrides the existing export with new one (will override export from Export Many)
        return info.Exports.AppendOrUpdate(export, info.Exports.IndexOf(export));
    }

    private static ExportInfo[] GetExportFromImplementationType(ExportedRegistrationInfo info, Type implementationType)
    {
        var export = new ExportInfo(implementationType);
        return info.Exports.AppendOrUpdate(export, info.Exports.IndexOf(export));
    }

    private static IfAlreadyRegistered GetIfAlreadyRegistered(IfAlreadyExported ifAlreadyExported)
    {
        switch (ifAlreadyExported)
        {
            case IfAlreadyExported.Throw: return IfAlreadyRegistered.Throw;
            case IfAlreadyExported.Keep: return IfAlreadyRegistered.Keep;
            case IfAlreadyExported.Replace: return IfAlreadyRegistered.Replace;
            case IfAlreadyExported.AppendNewImplementation: return IfAlreadyRegistered.AppendNewImplementation;
            default: return IfAlreadyRegistered.AppendNotKeyed;
        }
    }

    private static ExportInfo[] GetExportsFromExportManyAttribute(ExportManyAttribute attribute,
        ExportedRegistrationInfo info, Type implementationType)
    {
        var contractTypes = implementationType.GetRegisterManyImplementedServiceTypes(attribute.NonPublic);
        if (!attribute.Except.IsNullOrEmpty())
            contractTypes = contractTypes.Except(attribute.Except).ToArrayOrSelf();

        var manyExports = contractTypes
            .Map(contractType => new ExportInfo(contractType,
                attribute.ContractName ?? attribute.ContractKey, GetIfAlreadyRegistered(attribute.IfAlreadyExported)));

        if (manyExports.Length == 0)
            Throw.It(Error.ExportManyDoesNotExportAnyType, implementationType, contractTypes);

        // Filters exports that were already made, because ExportMany has less priority than Export(Ex)
        var currentExports = info.Exports;
        if (currentExports.IsNullOrEmpty())
        {
            currentExports = manyExports;
        }
        else
        {
            for (var i = 0; i < manyExports.Length; i++)
            {
                var manyExport = manyExports[i];
                if (!currentExports.Contains(manyExport))
                    currentExports = currentExports.AppendOrUpdate(manyExport);
            }
        }

        return currentExports;
    }

    private static void PopulateWrapperInfoFromAttribute(ExportedRegistrationInfo resultInfo, AsWrapperAttribute attribute,
        Type implementationType)
    {
        Throw.If(resultInfo.FactoryType != DryIoc.FactoryType.Service, Error.UnsupportedMultipleFactoryTypes, implementationType);
        resultInfo.FactoryType = DryIoc.FactoryType.Wrapper;
        resultInfo.Wrapper = new WrapperInfo
        {
            WrappedServiceTypeArgIndex = attribute.WrappedServiceTypeArgIndex,
            AlwaysWrapsRequiredServiceType = attribute.AlwaysWrapsRequiredServiceType
        };
    }

    private static void PopulateDecoratorInfoFromAttribute(
        ExportedRegistrationInfo resultInfo, AsDecoratorAttribute attribute, Type implementationType)
    {
        Throw.If(resultInfo.FactoryType != DryIoc.FactoryType.Service, Error.UnsupportedMultipleFactoryTypes, implementationType);
        resultInfo.FactoryType = DryIoc.FactoryType.Decorator;
        var decoratedServiceKey = attribute.ContractName ?? attribute.ContractKey;
        resultInfo.Decorator = new DecoratorInfo
        {
            DecoratedServiceKey = decoratedServiceKey,
            Order = attribute.Order,
            UseDecorateeReuse = attribute.UseDecorateeReuse
        };
    }

    private static Attribute[] GetAllExportAttributes(Type type)
    {
        var attributes = type.GetAttributes();

        for (var baseType = type.BaseType;
            baseType != typeof(object) && baseType != null;
            baseType = baseType.BaseType)
            attributes = attributes.Append(GetInheritedExportAttributes(baseType));

        var interfaces = type.GetInterfaces();
        if (interfaces.Length != 0)
            for (var i = 0; i < interfaces.Length; i++)
                attributes = attributes.Append(GetInheritedExportAttributes(interfaces[i]));

        return attributes;
    }

    private static Attribute[] GetInheritedExportAttributes(Type type)
    {
        var exports = type.GetAttributes(typeof(InheritedExportAttribute));
        for (var i = 0; i < exports.Length; i++)
        {
            var export = (InheritedExportAttribute)exports[i];
            if (export.ContractType == null)
                exports[i] = new InheritedExportAttribute(export.ContractName, type);
        }
        return exports;
    }

    #endregion
}

/// <summary>Names used by Attributed Model to mark the special exports.</summary>
public static class Constants
{
    /// <summary>Predefined key in metadata dictionary for metadata provided as single object (not dictionary).</summary>
    public static readonly string ExportMetadataDefaultKey = "@ExportMetadataDefaultKey";

    /// <summary>Marks the Export generated for type which export its instance members,
    /// but should not be resolved as-self by default.</summary>
    public static readonly string InstanceFactory = "@InstanceFactory";
}

/// <summary>Defines error codes and messages for <see cref="AttributedModelException"/>.</summary>
public static class Error
{
    /// <summary>Error messages for corresponding codes.</summary>
    public static readonly string[] Messages = new string[20];

    // note: the order of static initialization is important, that's why those are initialized before messages
    private static int _errorIndex = -1;
    private static readonly int _containerErrorCount = DryIoc.Error.Messages.Length;

#pragma warning disable 1591 // Missing XML-comment
    public static readonly int
        NoSingleCtorWithImportingAttr = Of(
            "Unable to find single constructor nor marked with " + typeof(ImportingConstructorAttribute) +
            " nor default constructor in {0} when resolving: {1}"),
        UnsupportedMultipleFactoryTypes = Of(
            "Found multiple factory types associated with exported {0}. Only single ExportAs.. attribute is supported, please remove the rest."),
        DuplicateMetadataKey = Of(
            "Duplicate metadata key {0} for the already defined {1}."),
        NoExport = Of(
            "At least one Export attributed should be defined for {0}."),
        ExportManyDoesNotExportAnyType = Of(
            "Unable to get contract types for implementation {0} because all of its implemented types where filtered out: {1}"),
        UnsupportedReuseType = Of(
            "Attributed model does not support reuse type {0}."),
        UnsupportedReuseWrapperType = Of(
            "Attributed model does not support reuse wrapper type {0}."),
        UnableToSelectFromMultipleTypes = Of(
            "Unable to select from multiple exported types {0} for the import {1}");
#pragma warning restore 1591

    private static int Of(string message)
    {
        var errorIndex = Interlocked.Increment(ref _errorIndex);
        Messages[errorIndex] = message;
        return errorIndex + _containerErrorCount;
    }

    internal static string GetMessage(int errorIndex) =>
        Messages[errorIndex - _containerErrorCount];

    /// <summary>Returns the name of error with the provided error code.</summary>
    public static string NameOf(int error) =>
        typeof(Error).GetTypeInfo().DeclaredFields
            .Where(f => f.FieldType == typeof(int))
            .Where((_, i) => i == error - _containerErrorCount + 1)
            .FirstOrDefault()?.Name;

    static Error()
    {
        Throw.GetMatchedException = GetAttributedModelOrContainerException;
    }

    private static Exception GetAttributedModelOrContainerException(
        ErrorCheck check, int error, object arg0, object arg1, object arg2, object arg3, Exception inner) =>
        error >= _containerErrorCount
            ? AttributedModelException.Of(check, error, arg0, arg1, arg2, arg3, inner)
            : ContainerException.Of(check, error, arg0, arg1, arg2, arg3, inner);
}

/// <summary>Specific exception type to be thrown by MefAttributedModel extension. Check <see cref="Error"/> for possible error cases.</summary>
public class AttributedModelException : ContainerException
{
    /// <summary>Creates exception by wrapping <paramref name="errorCode"/> and with message corresponding to code.</summary>
    public new static AttributedModelException Of(ErrorCheck errorCheck, int errorCode,
        object arg0, object arg1 = null, object arg2 = null, object arg3 = null,
        Exception inner = null)
    {
        var message = string.Format(MefAttributedModel.Error.GetMessage(errorCode), Print(arg0), Print(arg1), Print(arg2), Print(arg3));
        return inner == null
            ? new AttributedModelException(errorCode, message)
            : new AttributedModelException(errorCode, message, inner);
    }

    private AttributedModelException(int error, string message) : this(error, message, null) { }

    private AttributedModelException(int error, string message, Exception innerException) :
        base(error, message, innerException, (e, m, _) =>
        FormatMessage(MefAttributedModel.Error.NameOf(e), m))
    { }
}

// todo: @wip @simplify use FEC ToCode()
/// <summary>Converts provided literal into valid C# code. Used for generating registration code
/// from <see cref="ExportedRegistrationInfo"/> DTOs.</summary>
public static class PrintCode
{
    /// <summary>Prints valid c# Boolean literal: true/false.</summary>
    public static StringBuilder AppendBool(this StringBuilder code, bool x) =>
        code.Append(x.ToCode());

    /// <summary>Prints valid c# string constant.</summary>
    public static StringBuilder AppendString(this StringBuilder code, string x) =>
        code.Print(x);

    /// <summary>Prints valid c# Type literal: <c>typeof(Namespace.Type)</c>.</summary>
    public static StringBuilder AppendType(this StringBuilder code, Type x) =>
        code.AppendTypeOf(x);

    /// <summary>Prints valid c# Enum literal: Enum.Value.</summary>
    public static StringBuilder AppendEnum(this StringBuilder code, Type enumType, object x) =>
        code.Append(enumType.ToEnumValueCode(x));

    /// <summary>Prints the <see cref="Dictionary{TKey, TValue}"/> where keys are strings.</summary>
    public static StringBuilder AppendDictionary<TKey, TValue>(this StringBuilder code,
        IDictionary<TKey, TValue> dictionary, Func<StringBuilder, TKey, TValue, StringBuilder> appendValue = null)
    {
        if (appendValue == null)
            appendValue = (sb, key, value) => sb.AppendCode(value);
        code.Append("new ").Print(dictionary.GetType());
        code.AppendLine(" {");
        foreach (var pair in dictionary.OrderBy(p => p.Key))
        {
            code.Append("            { ");
            code.Append(pair.Key);
            code.Append(", ");
            code = appendValue(code, pair.Key, pair.Value);
            code.AppendLine(" },");
        }
        code.Append("        }");
        return code;
    }

    /// <summary>Prints the <see cref="Dictionary{TKey, TValue}"/> where keys and values are strings.</summary>
    public static StringBuilder AppendDictionary(this StringBuilder code, IDictionary<string, string> dictionary) =>
        code.AppendDictionary(dictionary, (c, k, v) => c.AppendString(v));

    /// <summary>Determines whether the type is null-able.</summary>
    public static bool IsNullable(this Type type) =>
        type.GetTypeInfo().IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>);

    /// <summary>Prints code items.</summary>
    public static StringBuilder AppendMany<T>(this StringBuilder code, IEnumerable<T> items)
    {
        code.Append("new ").Print(typeof(T)).Print("[] {");
        var count = 0;
        foreach (var item in items)
        {
            if (count++ != 0)
                code.Append(", ");
            code.AppendCode(item);
        }
        return code.Append("}");
    }

    /// <summary>Prints valid c# literal depending of <paramref name="x"/> type.</summary>
    public static StringBuilder AppendCode(this StringBuilder code, object x, Action<StringBuilder, object> ifNotRecognized = null)
    {
        if (x == null)
            return code.Append("null");
        if (x is bool)
            return code.AppendBool((bool)x);
        if (x is string)
            return code.AppendString((string)x);
        if (x is Type)
            return code.AppendType((Type)x);

        var type = x.GetType();
        if (type.IsEnum)
            return code.AppendEnum(type, x);

        if (ifNotRecognized != null)
            ifNotRecognized(code, x);
        else
            code.Append(x);

        return code;
    }
}

#region Registration Info DTOs
#pragma warning disable 659

// todo: @improve introduce Clone, may be move the State into stuct and add API to utilize the `with` syntax for customization
/// <summary>Serializable DTO of all registration information.</summary>
public sealed class ExportedRegistrationInfo
{
    /// <summary>All exports defined for implementation type (registration).</summary>
    public ExportInfo[] Exports;

    /// <summary>Concrete type on what exports are defined: exported type.</summary>
    /// <remarks>May be null if <see cref="ImplementationTypeFullName"/> specified.</remarks>
    public Type ImplementationType;

    /// <summary>Full name of exported type. Enables type lazy-loading scenario.</summary>
    public string ImplementationTypeFullName;

    /// <summary>Indicate the lazy info with the type defined by its name instead of Runtime Type.</summary>
    public bool IsLazy => ImplementationTypeFullName != null;

    /// <summary>Specifies the reuse information</summary>
    public ReuseInfo Reuse;

    /// <summary>Specifies all <see cref="Setup"/> flags.</summary>
    public Setup.Settings Flags;

    /// <summary>Corresponds to <see cref="Setup.OpenResolutionScope"/>.</summary>
    public bool OpenResolutionScope
    {
        get => (Flags & Setup.Settings.OpenResolutionScope) != 0;
        set => Flags = value ? Flags | Setup.Settings.OpenResolutionScope : Flags & ~Setup.Settings.OpenResolutionScope;
    }

    /// <summary>Corresponds to <see cref="Setup.AsResolutionCall"/>.</summary>
    public bool AsResolutionCall
    {
        get => (Flags & Setup.Settings.AsResolutionCall) != 0;
        set => Flags = value ? Flags | Setup.Settings.AsResolutionCall : Flags & ~Setup.Settings.AsResolutionCall;
    }

    /// <summary>Corresponds to <see cref="Setup.AsResolutionRoot"/>.</summary>
    public bool AsResolutionRoot
    {
        get => (Flags & Setup.Settings.AsResolutionRoot) != 0;
        set => Flags = value ? Flags | Setup.Settings.AsResolutionRoot : Flags & ~Setup.Settings.AsResolutionRoot;
    }

    /// <summary>Specifies to prevent disposal of reused instance if it is disposable</summary>
    public bool PreventDisposal
    {
        get => (Flags & Setup.Settings.PreventDisposal) != 0;
        set => Flags = value ? Flags | Setup.Settings.PreventDisposal : Flags & ~Setup.Settings.PreventDisposal;
    }

    /// <summary>Specifies to store reused instance as WeakReference.</summary>
    public bool WeaklyReferenced
    {
        get => (Flags & Setup.Settings.WeaklyReferenced) != 0;
        set => Flags = value ? Flags | Setup.Settings.WeaklyReferenced : Flags & ~Setup.Settings.WeaklyReferenced;
    }

    /// <summary>Allows registering transient disposable. But the disposal is up to you.</summary>
    public bool AllowDisposableTransient
    {
        get => (Flags & Setup.Settings.AllowDisposableTransient) != 0;
        set => Flags = value ? Flags | Setup.Settings.AllowDisposableTransient : Flags & ~Setup.Settings.AllowDisposableTransient;
    }

    /// <summary>Turns On tracking of disposable transient dependency in parent scope or in open scope if resolved directly.</summary>
    public bool TrackDisposableTransient
    {
        get => (Flags & Setup.Settings.TrackDisposableTransient) != 0;
        set => Flags = value ? Flags | Setup.Settings.TrackDisposableTransient : Flags & ~Setup.Settings.TrackDisposableTransient;
    }

    /// <summary>Instructs to use parent reuse. Applied only if Reuse is not specified.</summary>
    public bool UseParentReuse
    {
        get => (Flags & Setup.Settings.UseParentReuse) != 0;
        set => Flags = value ? Flags | Setup.Settings.UseParentReuse : Flags & ~Setup.Settings.UseParentReuse;
    }

    /// <summary>When single service is resolved, but multiple candidates found, this setting will be used to prefer this one.</summary>
    public bool PreferInSingleServiceResolve
    {
        get => (Flags & Setup.Settings.PreferInSingleServiceResolve) != 0;
        set => Flags = value ? Flags | Setup.Settings.PreferInSingleServiceResolve : Flags & ~Setup.Settings.PreferInSingleServiceResolve;
    }

    /// <summary>Does not add the resolution scope into the parent or singleton scope,
    /// preventing possibly unwanted holding of the scope (and its services) for the lifespan of the container.</summary>
    public bool AvoidResolutionScopeTracking
    {
        get => (Flags & Setup.Settings.AvoidResolutionScopeTracking) != 0;
        set => Flags = value ? Flags | Setup.Settings.AvoidResolutionScopeTracking : Flags & ~Setup.Settings.AvoidResolutionScopeTracking;
    }

    /// <summary>True if exported type has metadata.</summary>
    public bool HasMetadataAttribute;

    /// <summary>Relative disposal order when defined. Greater number, later dispose.</summary>
    public int DisposalOrder;

    /// <summary>Gets or sets the metadata.</summary>
    public IDictionary<string, object> Metadata;

    /// <summary>Factory type to specify <see cref="Setup"/>.</summary>
    public DryIoc.FactoryType FactoryType;

    /// <summary>Type consisting of single method compatible with <see cref="Setup.Condition"/> type.</summary>
    public Type ConditionType;

    /// <summary>Not null if exported with <see cref="AsDecoratorAttribute"/>, contains info about decorator.</summary>
    public DecoratorInfo Decorator;

    /// <summary>Not null if exported with <see cref="AsWrapperAttribute"/>, contains info about wrapper.</summary>
    public WrapperInfo Wrapper;

    /// <summary>Not null for exported members.</summary>
    public FactoryMethodInfo FactoryMethodInfo;

    /// <summary>Returns new info with type representation as type full name string, instead of actual type.</summary>
    /// <returns>New lazy ExportInfo for not lazy this, otherwise - this one.</returns>
    public ExportedRegistrationInfo MakeLazy()
    {
        if (IsLazy) return this;
        var newInfo = (ExportedRegistrationInfo)MemberwiseClone();
        newInfo.ImplementationTypeFullName = ImplementationType.FullName;
        newInfo.ImplementationType = null;
        var exports = newInfo.Exports;
        for (var i = 0; i < exports.Length; i++)
            exports[i] = exports[i].MakeLazy();
        if (newInfo.FactoryMethodInfo != null)
            newInfo.FactoryMethodInfo = newInfo.FactoryMethodInfo.MakeLazy();
        return newInfo;
    }

    /// <summary>De-duplicates service keys in export via tracking they uniqueness in passed store.
    /// The result key would be a pair of original key and index. If key is already unique it will be returned as-is.</summary>
    /// <param name="index">Place to track and check the key uniqueness.</param>
    /// <returns>Modifies this, and return this just for fluency.</returns>
    public ExportedRegistrationInfo EnsureUniqueExportServiceKeys(ServiceKeyToTypeIndex index)
    {
        var exports = Exports;
        for (var i = 0; i < exports.Length; i++)
        {
            var e = exports[i];
            var key = e.ServiceKey;
            if (key != null)
                e.ServiceKey = index.EnsureUniqueServiceKey((object)e.ServiceType ?? e.ServiceTypeFullName, key);
        }
        return this;
    }

    /// <summary>Creates factory from registration info.</summary>
    /// <param name="typeProvider">(optional) Required for Lazy registration info to create actual Type from type name.</param>
    /// <returns>Created factory.</returns>
    public ReflectionFactory CreateFactory(Func<string, Type> typeProvider = null)
    {
        if (!IsLazy)
            return ReflectionFactory.Of(ImplementationType, GetReuse(), GetMade(), GetSetup());

        typeProvider = typeProvider.ThrowIfNull();
        var made = GetMade(typeProvider);
        var setup = GetSetup(made);
        return ReflectionFactory.Of(() => typeProvider(ImplementationTypeFullName), GetReuse(), made, setup);
    }

    // todo: fix multi-threading
    /// <summary>Returns the already created factory if any.</summary>
    public ReflectionFactory GetOrCreateFactory(Func<string, Type> typeProvider = null) =>
        _createdFactory ?? (_createdFactory = CreateFactory(typeProvider));

    private ReflectionFactory _createdFactory;

    private Made GetMade(Func<string, Type> typeProvider = null) =>
        FactoryMethodInfo == null ? Made.Default : FactoryMethodInfo.CreateMade(typeProvider);

    /// <summary>Gets the <see cref="IReuse"/> instance.</summary>
    public IReuse GetReuse() => AttributedModel.GetReuse(Reuse);

    /// <summary>Create factory setup from registration DTO.</summary>
    /// <param name="made">(optional) Used for collecting metadata from factory method attributes if any.</param>
    /// <returns>Created factory setup.</returns>
    public Setup GetSetup(Made made = null)
    {
        if (FactoryType == DryIoc.FactoryType.Wrapper)
            return Wrapper == null ? Setup.Wrapper : Wrapper.GetSetup();

        var condition = ConditionType == null
            ? (Func<DryIoc.Request, bool>)null
            : r => ((ExportConditionAttribute)Activator.CreateInstance(ConditionType))
                .Evaluate(ConvertRequestInfo(r));

        if (FactoryType == DryIoc.FactoryType.Decorator)
            return Decorator == null ? Setup.Decorator : Decorator.GetSetup(condition);

        object metadata = Metadata;
        if (metadata == null && HasMetadataAttribute)
            metadata = IsLazy
                ? new Func<object>(() => CollectExportedMetadata(CollectMetadataAttributes(made)))
                : (object)CollectExportedMetadata(CollectMetadataAttributes(made));

        return Setup.With(metadata, condition,
            OpenResolutionScope, AsResolutionCall, AsResolutionRoot,
            PreventDisposal, WeaklyReferenced,
            AllowDisposableTransient, TrackDisposableTransient,
            UseParentReuse, DisposalOrder, PreferInSingleServiceResolve, AvoidResolutionScopeTracking);
    }

    private IEnumerable<Attribute> CollectMetadataAttributes(Made made)
    {
        if (ImplementationType == null)
            return ArrayTools.Empty<Attribute>();

        IEnumerable<Attribute> metaAttrs = ImplementationType.GetAttributes();
        if (made?.FactoryMethodKnownResultType != null)
        {
            var member = (made.FactoryMethodOrSelector as FactoryMethod ?? ((FactoryMethodSelector)made.FactoryMethodOrSelector)(null))?.ConstructorOrMethodOrMember;
            if (member != null)
                metaAttrs = metaAttrs.Concat(member.GetAttributes());
        }
        return metaAttrs;
    }

    private static Request ConvertRequestInfo(DryIoc.Request source)
    {
        if (source.IsEmpty)
            return Request.Empty;

        var factoryType =
            source.FactoryType == DryIoc.FactoryType.Decorator ? DryIocAttributes.FactoryType.Decorator :
            source.FactoryType == DryIoc.FactoryType.Wrapper ? DryIocAttributes.FactoryType.Wrapper :
            DryIocAttributes.FactoryType.Service;

        var d = source.GetServiceDetails();
        var ifUnresolved = d.IfUnresolved == DryIoc.IfUnresolved.Throw ? IfUnresolved.Throw : IfUnresolved.ReturnDefault;

        return ConvertRequestInfo(source.DirectParent).Push(
            source.ServiceType,
            d.RequiredServiceType,
            d.ServiceKey,
            d.MetadataKey, d.Metadata,
            ifUnresolved,
            source.FactoryID,
            factoryType,
            source.ImplementationType,
            source.ReuseLifespan);
    }

    /// <summary>Compares with another info for equality.</summary>
    public override bool Equals(object obj)
    {
        var other = obj as ExportedRegistrationInfo;
        return other != null
            && other.ImplementationType == ImplementationType
            && Equals(other.Reuse, Reuse)
            && other.FactoryType == FactoryType
            && Equals(other.Wrapper, Wrapper)
            && Equals(other.Decorator, Decorator)
            && other.Exports.SequenceEqual(Exports);
    }

    /// <summary>Generate valid c# code for instantiating of info from its state. Supposed be used in compile-time scenarios.</summary>
    public StringBuilder ToCode(StringBuilder code = null)
    {
        code = code ?? new StringBuilder();
        code.Append(@"
    new ExportedRegistrationInfo {
        ImplementationType = ").AppendType(ImplementationType).Append(@",
        Exports = new[] {
        "); for (var i = 0; i < Exports.Length; i++)
            code = Exports[i].ToCode(code.Append("    ")).Append(@",
        "); code.Append("}");
        if (Reuse != null) Reuse.ToCode(code.Append(@",
        Reuse = ")); code.Append(@",
        OpenResolutionScope = ").AppendBool(OpenResolutionScope).Append(@",
        AsResolutionCall = ").AppendBool(AsResolutionCall).Append(@",
        AsResolutionRoot = ").AppendBool(AsResolutionRoot).Append(@",
        PreventDisposal = ").AppendBool(PreventDisposal).Append(@",
        WeaklyReferenced = ").AppendBool(WeaklyReferenced).Append(@",
        AllowDisposableTransient = ").AppendBool(AllowDisposableTransient).Append(@",
        TrackDisposableTransient = ").AppendBool(TrackDisposableTransient).Append(@",
        UseParentReuse = ").AppendBool(UseParentReuse).Append(@",
        HasMetadataAttribute = ").AppendBool(HasMetadataAttribute).Append(@",
        FactoryType = ").AppendEnum(typeof(DryIoc.FactoryType), FactoryType).Append(@",
        ConditionType = ").AppendType(ConditionType);
        if (Metadata != null) code.Append(@",
        Metadata = ").AppendDictionary(Metadata, MetadataItemToCode);
        if (Wrapper != null) Wrapper.ToCode(code.Append(@",
        Wrapper = "));
        if (Decorator != null) Decorator.ToCode(code.Append(@",
        Decorator = "));
        if (FactoryMethodInfo != null) FactoryMethodInfo.ToCode(code.Append(@",
        FactoryMethodInfo = ")); code.Append(@"
    }");
        return code;
    }

    private StringBuilder MetadataItemToCode(StringBuilder code, string key, object value)
    {
        object metadataCode;
        return Metadata != null &&
               Metadata.TryGetValue(key + ToCodeKeySuffix, out metadataCode)
            ? code.Append(metadataCode)
            : code.AppendCode(value);
    }

    /// <summary>Collects the metadata as <see cref="Dictionary{TKey, TValue}"/>.</summary>
    public void InitExportedMetadata(Attribute[] attributes)
    {
        Metadata = CollectExportedMetadata(attributes);
        if (Metadata != null)
            CollectAttributeConstructorsCode(Metadata);
    }

    /// <summary>Metadata key suffix for the C# representation of the custom attribute constructors.</summary>
    public const string ToCodeKeySuffix = ".ToCode()";
    private void CollectAttributeConstructorsCode(IDictionary<string, object> metadata)
    {
        var attributes = CustomAttributeData.GetCustomAttributes(ImplementationType);
        foreach (var a in attributes)
        {
            var fullTypeName = a.Constructor.DeclaringType.FullName;
            if (metadata.ContainsKey(fullTypeName))
            {
                var args = string.Join(", ", ArrayTools.Map(a.ConstructorArguments, x => x.ToString()).ToArrayOrSelf());
                var ctor = string.Format("new {0}({1})", fullTypeName, args);
                if (a.NamedArguments.Any())
                    ctor += " { " + string.Join(", ", a.NamedArguments.Map(na => na.MemberInfo.Name + " = " + na.TypedValue).ToArrayOrSelf()) + " }";
                metadata[fullTypeName + ToCodeKeySuffix] = ctor;
            }
        }
    }

    private static IDictionary<string, object> CollectExportedMetadata(IEnumerable<Attribute> attributes)
    {
        Dictionary<string, object> metaDict = null;

        var metadataAttributes = attributes
            .Where(static a => a is ExportMetadataAttribute || a is WithMetadataAttribute
                || a.GetType().GetAttributes(typeof(MetadataAttributeAttribute), true).Any())
            .OrderBy(static a => a.GetType().FullName);

        foreach (var metaAttr in metadataAttributes)
        {
            string metaKey;
            object metaValue = metaAttr;
            var addProperties = false;

            if (metaAttr is ExportMetadataAttribute)
            {
                var exportMetaAttr = (ExportMetadataAttribute)metaAttr;
                metaKey = exportMetaAttr.Name; // note: defaults to string.Empty
                metaValue = exportMetaAttr.Value;
            }
            else if (metaAttr is WithMetadataAttribute)
            {
                var withMetadataAttr = (WithMetadataAttribute)metaAttr;
                metaKey = withMetadataAttr.MetadataKey ?? Constants.ExportMetadataDefaultKey;
                metaValue = withMetadataAttr.Metadata;
            }
            else
            {
                // index custom metadata attributes with their type name
                metaKey = metaAttr.GetType().FullName ?? metaAttr.GetType().Name;
                addProperties = true;
            }

            if (metaDict != null && metaDict.ContainsKey(metaKey))
                Throw.It(Error.DuplicateMetadataKey, metaKey, metaDict);

            metaDict ??= new Dictionary<string, object>();
            metaDict.Add(metaKey, metaValue);

            if (addProperties)
            {
                var metaTypes = new List<TypeInfo>();
                var metaType = metaAttr.GetType();
                while (metaType != null && metaType != typeof(Attribute) && metaType != typeof(ExportAttribute))
                {
                    var metaTypeInfo = metaType.GetTypeInfo();
                    metaTypes.Add(metaTypeInfo);
                    metaType = metaTypeInfo.BaseType;
                }

                var properties = metaTypes.SelectMany(t => t.DeclaredProperties);
                foreach (var property in properties)
                {
                    metaKey = property.Name;
                    metaValue = property.GetValue(metaAttr, new object[0]);

                    if (metaDict.ContainsKey(metaKey))
                        Throw.It(Error.DuplicateMetadataKey, metaKey, metaDict);

                    metaDict.Add(metaKey, metaValue);
                }
            }
        }

        return metaDict;
    }
}

/// <summary>Serializable info about exported member, aka factory method in DryIoc.</summary>
public sealed class FactoryMethodInfo
{
    /// <summary>The type declaring the member.</summary>
    public Type DeclaringType;

    /// <summary>The declaring type name.</summary>
    public string DeclaringTypeFullName;

    /// <summary>Member defining the Export.</summary>
    public string MemberName;

    /// <summary>Parameter type full names (and names for generic parameters) to identify the method overload.</summary>
    public string[] MethodParameterTypeFullNamesOrNames;

    /// <summary>(optional) Not null for exported instance member which requires factory object, null for static members.</summary>
    public ExportInfo InstanceFactory;

    /// <summary>Indicate the lazy info with the type defined by its name instead of Runtime Type.</summary>
    public bool IsLazy => DeclaringTypeFullName != null;

    /// <summary>Returns new export info with type representation as type full name string, instead of actual type.</summary>
    public FactoryMethodInfo MakeLazy()
    {
        if (IsLazy) return this;
        var info = (FactoryMethodInfo)MemberwiseClone();
        info.DeclaringTypeFullName = DeclaringType.FullName;
        info.DeclaringType = null;
        if (info.InstanceFactory != null)
            info.InstanceFactory = info.InstanceFactory.MakeLazy();
        return info;
    }

    /// <summary>Constructs Made out of info properties.</summary>
    public Made CreateMade(Func<string, Type> typeProvider = null)
    {
        if (!IsLazy)
            return Made.Of(GetMember(DeclaringType),
                InstanceFactory == null ? null : ServiceInfo.Of(
                    InstanceFactory.ServiceType, DryIoc.IfUnresolved.ReturnDefault, InstanceFactory.ServiceKey));

        typeProvider = typeProvider.ThrowIfNull();
        return Made.Of(_ => FactoryMethod.Of(
            GetMember(typeProvider(DeclaringTypeFullName)),
            InstanceFactory == null ? null : ServiceInfo.Of(
                InstanceFactory.ServiceType ?? typeProvider(InstanceFactory.ServiceTypeFullName),
                DryIoc.IfUnresolved.ReturnDefault, InstanceFactory.ServiceKey)));
    }

    private MemberInfo GetMember(Type declaringType) =>
        declaringType
            .GetAllMembers(includeBase: true)
            .FirstOrDefault(m =>
            {
                if (m.Name != MemberName)
                    return false;

                var method = m as MethodInfo;
                if (method == null) // return early if it is property or field, no need to compare method signature
                    return true;

                var parameters = method.GetParameters();
                var factoryMethodParameterTypeNames = MethodParameterTypeFullNamesOrNames ?? ArrayTools.Empty<string>();
                if (parameters.Length != factoryMethodParameterTypeNames.Length)
                    return false;

                return parameters.Length == 0
                       || parameters.Select(p => p.ParameterType.FullName ?? p.ParameterType.Name)
                           .SequenceEqual(factoryMethodParameterTypeNames);
            })
            .ThrowIfNull();

    /// <summary>Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.</summary>
    public override bool Equals(object obj)
    {
        var other = obj as FactoryMethodInfo;
        return other != null
            && other.DeclaringType == DeclaringType
            && other.MemberName == MemberName
            && (other.MethodParameterTypeFullNamesOrNames == null && MethodParameterTypeFullNamesOrNames == null ||
                other.MethodParameterTypeFullNamesOrNames != null && MethodParameterTypeFullNamesOrNames != null &&
                other.MethodParameterTypeFullNamesOrNames.SequenceEqual(MethodParameterTypeFullNamesOrNames))
            && Equals(other.InstanceFactory, InstanceFactory);
    }

    /// <summary>Generates valid c# code to re-create the info.</summary>
    public StringBuilder ToCode(StringBuilder code)
    {
        code.Append(@"new FactoryMethodInfo {
            DeclaringType = ").AppendType(DeclaringType).Append(@",
            MemberName = ").AppendString(MemberName);
        if (!MethodParameterTypeFullNamesOrNames.IsNullOrEmpty()) code.Append(@",
            MethodParameterTypeFullNamesOrNames = ").AppendMany(MethodParameterTypeFullNamesOrNames);
        if (InstanceFactory != null) InstanceFactory.ToCode(code.Append(@",
            InstanceFactory = "));
        return code.Append(@"
        }");
    }
}

/// <summary>Specifies the standard and custom reuse info.</summary>
public sealed class ReuseInfo
{
    /// <summary>One of <see cref="AttributedModel.SupportedReuseTypes"/>.</summary>
    public ReuseType ReuseType;

    /// <summary>Name of the scope to pass to reuse factory from <see cref="AttributedModel.SupportedReuseTypes"/>.</summary>
    public string ScopeName;

    /// <summary>The object names of the scope. Maybe overridden by <see cref="ScopeName"/></summary>
    public object[] ScopeNames;

    /// <summary>Custom reuse type, overrides the <see cref="ReuseType"/>.</summary>
    public Type CustomReuseType;

    /// <summary>Compares with another info for equality.</summary>
    public override bool Equals(object obj) =>
        obj is ReuseInfo other
        && other.ReuseType == ReuseType
        && other.CustomReuseType == CustomReuseType
        && other.ScopeName == ScopeName
        && (other.ScopeNames == null && ScopeNames == null || (other.ScopeNames?.SequenceEqual(ScopeNames) ?? false));

    /// <summary>Converts info to the C# code representation.</summary>
    public StringBuilder ToCode(StringBuilder code)
    {
        code = CustomReuseType == null
            ? code.Append("new ReuseInfo { ReuseType = ").AppendEnum(typeof(ReuseType), ReuseType)
            : code.Append("new ReuseInfo { CustomReuseType = ").AppendType(CustomReuseType);

        if (ScopeName != null)
            code = code.Append(", ScopeName = ").AppendString(ScopeName);
        else if (ScopeNames != null && ScopeNames.Length > 0)
            code = code.Append(", ScopeNames = ").AppendMany(ScopeNames);

        return code.Append(" }");
    }
}

/// <summary>Defines DTO for exported service type and key.</summary>
public sealed class ExportInfo
{
    /// <summary>Contract type.</summary>
    /// <remarks>may be null if <see cref="ServiceTypeFullName"/> specified.</remarks>
    public Type ServiceType;

    /// <summary>Full contract type name. Supposed to be used in lazy-loading scenario.</summary>
    public string ServiceTypeFullName;

    /// <summary>Wrapped contract name or service key.</summary>
    public object ServiceKey;

    /// <summary>If already registered option to pass to container registration.</summary>
    public IfAlreadyRegistered IfAlreadyRegistered;

    /// <summary>Indicate the lazy info with type defined by its name instead of Runtime Type.</summary>
    public bool IsLazy => ServiceTypeFullName != null;

    /// <summary>Default constructor is usually required by de-serializer.</summary>
    public ExportInfo() { }

    /// <summary>Creates exported info out of type and optional key.</summary>
    public ExportInfo(Type serviceType, object serviceKey = null,
        IfAlreadyRegistered ifAlreadyRegistered = IfAlreadyRegistered.AppendNotKeyed)
    {
        ServiceType = serviceType;
        ServiceKey = serviceKey;
        IfAlreadyRegistered = ifAlreadyRegistered;
    }

    /// <summary>Creates exported info out of type and optional key.</summary>
    public ExportInfo(string serviceTypeFullName, object serviceKey = null,
        IfAlreadyRegistered ifAlreadyRegistered = IfAlreadyRegistered.AppendNotKeyed)
    {
        ServiceTypeFullName = serviceTypeFullName;
        ServiceKey = serviceKey;
        IfAlreadyRegistered = ifAlreadyRegistered;
    }

    /// <summary>Compares with another info for equality.</summary>
    /// <param name="obj">Other info to compare.</param> <returns>True if equal.</returns>
    public override bool Equals(object obj)
    {
        var other = obj as ExportInfo;
        return other != null
            && other.ServiceType == ServiceType
            && Equals(other.ServiceKey, ServiceKey)
            && other.IfAlreadyRegistered == IfAlreadyRegistered;
    }

    /// <summary>Generates valid c# code to re-create the info.</summary>
    /// <param name="code">Code to append generated code to.</param>
    /// <returns>Code with appended generated info.</returns>
    public StringBuilder ToCode(StringBuilder code = null) =>
        (code ?? new StringBuilder())
            .Append("new ExportInfo(").AppendType(ServiceType).Append(", ")
            .AppendCode(ServiceKey).Append(", ")
            .AppendEnum(typeof(IfAlreadyRegistered), IfAlreadyRegistered)
            .Append(")");

    /// <summary>Returns new export info with type representation as type full name string, instead of
    /// actual type.</summary> <returns>New lazy ExportInfo for not lazy this, otherwise - this one.</returns>
    public ExportInfo MakeLazy()
    {
        if (IsLazy) return this;
        var info = (ExportInfo)MemberwiseClone();
        info.ServiceTypeFullName = ServiceType.FullName;
        info.ServiceType = null;
        return info;
    }
}

/// <summary>Defines wrapper setup in serializable way.</summary>
public sealed class WrapperInfo
{
    /// <summary>Index of wrapped type argument in open-generic wrapper.</summary>
    public int WrappedServiceTypeArgIndex;

    /// <summary>Per name.</summary>
    public bool AlwaysWrapsRequiredServiceType;

    /// <summary>Creates Wrapper setup from this info.</summary>
    public Setup GetSetup() =>
        Setup.WrapperWith(WrappedServiceTypeArgIndex, AlwaysWrapsRequiredServiceType);

    /// <summary>Used to compare wrappers info for equality.</summary>
    public override bool Equals(object obj)
    {
        var other = obj as WrapperInfo;
        return other != null
            && other.WrappedServiceTypeArgIndex == WrappedServiceTypeArgIndex
            && other.AlwaysWrapsRequiredServiceType == AlwaysWrapsRequiredServiceType;
    }

    /// <summary>Converts info to valid C# code to be used in generation scenario.</summary>
    public StringBuilder ToCode(StringBuilder code = null) =>
        (code ?? new StringBuilder())
            .Append("new WrapperInfo { WrappedServiceTypeArgIndex = ")
            .AppendCode(WrappedServiceTypeArgIndex).Append(", AlwaysWrapsRequiredServiceType = ")
            .AppendBool(AlwaysWrapsRequiredServiceType).Append(" }");
}

/// <summary>Provides serializable info about Decorator setup.</summary>
public sealed class DecoratorInfo
{
    /// <summary>Decorated service key.</summary>
    public object DecoratedServiceKey;

    /// <summary>Controls the order that decorators are registered in the container when multiple decorators are used for a single type.</summary>
    public int Order;

    /// <summary>Instructs to use decorated service reuse. Decorated service may be decorator itself.</summary>
    public bool UseDecorateeReuse;

    /// <summary>Converts info to corresponding decorator setup.</summary>
    public Setup GetSetup(Func<DryIoc.Request, bool> condition = null) =>
        DecoratedServiceKey == null && condition == null && Order == 0 && !UseDecorateeReuse
        ? Setup.Decorator
        : Setup.DecoratorWith(r =>
            (DecoratedServiceKey == null || Equals(DecoratedServiceKey, r.ServiceKey)) &&
            (condition == null || condition(r)),
            Order, UseDecorateeReuse);

    /// <summary>Compares this info to other info for equality.</summary>
    public override bool Equals(object obj)
    {
        var other = obj as DecoratorInfo;
        return other != null && Equals(other.DecoratedServiceKey, DecoratedServiceKey);
    }

    /// <summary>Converts info to valid C# code to be used in generation scenario.</summary>
    public StringBuilder ToCode(StringBuilder code) =>
        code.Append("new DecoratorInfo { DecoratedServiceKey = ")
            .AppendCode(DecoratedServiceKey).Append(", Order = ").AppendCode(Order)
            .Append(", UseDecorateeReuse = ").AppendBool(UseDecorateeReuse).Append(" }");
}
#pragma warning restore 659
#endregion

#nullable restore