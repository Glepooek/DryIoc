namespace DryIoc.CompileTimeContainer.SourceGenerator;

using System;
using System.Linq;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using DryIoc;
using DryIoc.ImTools;

/// <summary>Source Generator implementing the ICompileTimeContainer from the CompileTimeContainerAttribute, RegisterAttribute(s)</summary>
[Generator]
public class CompileTimeContainerGenerator : IIncrementalGenerator
{
    /// <summary>Hook SG on the class with CompileTimeContainerAttribute</summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        if (!Debugger.IsAttached)
        {
            Debugger.Launch();
        }
#endif

        var registerAttributes = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                $"DryIoc.{nameof(CompileTimeContainerAttribute)}",
                predicate: static (s, _) => true,
                transform: static (ctx, _) =>
                {
                    var typeSymbol = ctx.TargetSymbol as INamedTypeSymbol;
                    if (typeSymbol is null)
                        return null;

                    var comp = ctx.SemanticModel.Compilation;

                    var attrs = typeSymbol.GetAttributes();
                    foreach (var attr in attrs)
                    {
                        var attrName = attr.AttributeClass?.Name;
                        if (attrName == nameof(CompileTimeContainerAttribute))
                            continue;

                        if (attrName == nameof(RegisterAttribute))
                        {
                            // todo: @wip construct the RegisterAttribute from the attribute data
                            // 1. Get the ImplementationType and ServiceType from the attribute data
                            var implementationType = attr.ConstructorArguments[0].Value as INamedTypeSymbol;
                            var serviceType = attr.ConstructorArguments[1].Value as INamedTypeSymbol;

                            // 2. Convert the INamedTypeSymbol to the type with the Semantic model
                            var implType = comp.GetTypeByMetadataName(implementationType.ToDisplayString());
                            var servType = comp.GetTypeByMetadataName(serviceType.ToDisplayString());

                        }
                    }

                    return ArrayTools.Empty<RegisterAttribute>();
                })
            .Where(static m => m is not null);

        context.RegisterSourceOutput(registerAttributes, static (ctx, regAttrs) =>
        {
            var source = "// <auto-generated/>";
            var fileName = "CompTimeContainer.g.cs";

            ctx.AddSource(fileName, source);
        });
    }
}
